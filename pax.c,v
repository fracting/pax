head	1.1;
branch	1.1.221;
access;
symbols
	pax-20120606-2+deb7u1:1.1.221.6
	wheezy:1.1.221.6.0.2
	pax-20120606-3:1.1.221.6
	pax-20120606-2:1.1.221.6
	pax-20120606-1:1.1.221.6
	pax-20120606:1.1.221.6
	pax-20120605-1:1.1.221.6
	pax-20120605:1.1.221.6
	pax-20120520-1:1.1.221.5
	pax-20120520:1.1.221.5
	pax-20120216-2:1.1.221.4
	pax-20120216-1:1.1.221.4
	pax-20120216:1.1.221.4
	pax-20120212-1:1.1.221.3
	pax-20120212:1.1.221.3
	pax-20120211-1:1.1.221.3
	pax-20120211:1.1.221.3
	mircpio_20110817:1.1.221.2
	mircpio-20091122:1.1.221.1
	mircpio-20080906:1.1.221.1
	origtgz:1.1.221;
locks; strict;
comment	@ * @;
expand	@b@;


1.1
date	2011.07.28.16.48.00;	author tg;	state Exp;
branches
	1.1.221.1;
next	;
commitid	1004E3192C8046E063B;

1.1.221.1
date	2011.07.28.16.48.00;	author tg;	state Exp;
branches;
next	1.1.221.2;
commitid	1004E3192C8046E063B;

1.1.221.2
date	2011.08.17.09.18.31;	author tg;	state Exp;
branches;
next	1.1.221.3;
commitid	1004E4B875015FAFEA7;

1.1.221.3
date	2012.02.12.02.23.20;	author tg;	state Exp;
branches;
next	1.1.221.4;
commitid	1004F372297099197B4;

1.1.221.4
date	2012.02.16.17.56.57;	author tg;	state Exp;
branches;
next	1.1.221.5;
commitid	1004F3D436E207CDFC6;

1.1.221.5
date	2012.05.20.17.38.56;	author tg;	state Exp;
branches;
next	1.1.221.6;
commitid	1004FB92C473E896F98;

1.1.221.6
date	2012.06.05.19.31.59;	author tg;	state Exp;
branches;
next	;
commitid	1004FCE5EBC0C8B75D5;


desc
@@


1.1
log
@Initial revision
@
text
@/**	$MirOS: src/bin/pax/pax.c,v 1.7 2007/02/17 04:52:41 tg Exp $ */
/*	$OpenBSD: pax.c,v 1.28 2005/08/04 10:02:44 mpf Exp $	*/
/*	$NetBSD: pax.c,v 1.5 1996/03/26 23:54:20 mrg Exp $	*/

/*-
 * Copyright (c) 1992 Keith Muller.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Keith Muller of the University of California, San Diego.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <signal.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <err.h>
#include <fcntl.h>
#include <paths.h>
#include "pax.h"
#include "extern.h"

__COPYRIGHT("@@(#) Copyright (c) 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n");
__SCCSID("@@(#)pax.c	8.2 (Berkeley) 4/18/94");
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.7 2007/02/17 04:52:41 tg Exp $");

static int gen_init(void);
static void sig_cleanup(int) __attribute__((noreturn));

/*
 * PAX main routines, general globals and some simple start up routines
 */

/*
 * Variables that can be accessed by any routine within pax
 */
int	act = ERROR;		/* read/write/append/copy */
FSUB	*frmt = NULL;		/* archive format type */
int	cflag;			/* match all EXCEPT pattern/file */
int	cwdfd;			/* starting cwd */
int	dflag;			/* directory member match only  */
int	iflag;			/* interactive file/archive rename */
int	kflag;			/* do not overwrite existing files */
int	lflag;			/* use hard links when possible */
int	nflag;			/* select first archive member match */
int	tflag;			/* restore access time after read */
int	uflag;			/* ignore older modification time files */
int	vflag;			/* produce verbose output */
int	Dflag;			/* same as uflag except inode change time */
int	Hflag;			/* follow command line symlinks (write only) */
int	Lflag;			/* follow symlinks when writing */
int	Xflag;			/* archive files with same device id only */
int	Yflag;			/* same as Dflag except after name mode */
int	Zflag;			/* same as uflag except after name mode */
int	zeroflag;		/* use \0 as pathname terminator */
int	vfpart;			/* is partial verbose output in progress */
int	patime = 1;		/* preserve file access time */
int	pmtime = 1;		/* preserve file modification times */
int	nodirs;			/* do not create directories as needed */
int	pmode;			/* preserve file mode bits */
int	pids;			/* preserve file uid/gid */
int	rmleadslash = 0;	/* remove leading '/' from pathnames */
int	exit_val;		/* exit value */
int	docrc;			/* check/create file crc */
char	*dirptr;		/* destination dir in a copy */
char	*ltmfrmt;		/* -v locale time format (if any) */
const char *argv0;		/* root of argv[0] */
sigset_t s_mask;		/* signal mask for cleanup critical sect */
FILE	*listf;			/* fp to print file list to (default stderr) */
char	*tempfile;		/* tempfile to use for mkstemp(3) */
char	*tempbase;		/* basename of tempfile to use for mkstemp(3) */

/*
 *	PAX - Portable Archive Interchange
 *
 *	A utility to read, write, and write lists of the members of archive
 *	files and copy directory hierarchies. A variety of archive formats
 *	are supported (some are described in POSIX 1003.1 10.1):
 *
 *		ustar - 10.1.1 extended tar interchange format
 *		cpio  - 10.1.2 extended cpio interchange format
 *		tar - old BSD 4.3 tar format
 *		binary cpio - old cpio with binary header format
 *		sysVR4 cpio -  with and without CRC
 *
 * This version is a superset of IEEE Std 1003.2b-d3
 *
 * Summary of Extensions to the IEEE Standard:
 *
 * 1	READ ENHANCEMENTS
 * 1.1	Operations which read archives will continue to operate even when
 *	processing archives which may be damaged, truncated, or fail to meet
 *	format specs in several different ways. Damaged sections of archives
 *	are detected and avoided if possible. Attempts will be made to resync
 *	archive read operations even with badly damaged media.
 * 1.2	Blocksize requirements are not strictly enforced on archive read.
 *	Tapes which have variable sized records can be read without errors.
 * 1.3	The user can specify via the non-standard option flag -E if error
 *	resync operation should stop on a media error, try a specified number
 *	of times to correct, or try to correct forever.
 * 1.4	Sparse files (lseek holes) stored on the archive (but stored with blocks
 *	of all zeros will be restored with holes appropriate for the target
 *	filesystem
 * 1.5	The user is notified whenever something is found during archive
 *	read operations which violates spec (but the read will continue).
 * 1.6	Multiple archive volumes can be read and may span over different
 *	archive devices
 * 1.7	Rigidly restores all file attributes exactly as they are stored on the
 *	archive.
 * 1.8	Modification change time ranges can be specified via multiple -T
 *	options. These allow a user to select files whose modification time
 *	lies within a specific time range.
 * 1.9	Files can be selected based on owner (user name or uid) via one or more
 *	-U options.
 * 1.10	Files can be selected based on group (group name or gid) via one o
 *	more -G options.
 * 1.11	File modification time can be checked against existing file after
 *	name modification (-Z)
 *
 * 2	WRITE ENHANCEMENTS
 * 2.1	Write operation will stop instead of allowing a user to create a flawed
 *	flawed archive (due to any problem).
 * 2.2	Archives written by pax are forced to strictly conform to both the
 *	archive and pax the specific format specifications.
 * 2.3	Blocking size and format is rigidly enforced on writes.
 * 2.4	Formats which may exhibit header overflow problems (they have fields
 *	too small for large file systems, such as inode number storage), use
 *	routines designed to repair this problem. These techniques still
 *	conform to both pax and format specifications, but no longer truncate
 *	these fields. This removes any restrictions on using these archive
 *	formats on large file systems.
 * 2.5	Multiple archive volumes can be written and may span over different
 *	archive devices
 * 2.6	A archive volume record limit allows the user to specify the number
 *	of bytes stored on an archive volume. When reached the user is
 *	prompted for the next archive volume. This is specified with the
 *	non-standard -B flag. The limit is rounded up to the next blocksize.
 * 2.7	All archive padding during write use zero filled sections. This makes
 *	it much easier to pull data out of flawed archive during read
 *	operations.
 * 2.8	Access time reset with the -t applies to all file nodes (including
 *	directories).
 * 2.9	Symbolic links can be followed with -L (optional in the spec).
 * 2.10	Modification or inode change time ranges can be specified via
 *	multiple -T options. These allow a user to select files whose
 *	modification or inode change time lies within a specific time range.
 * 2.11	Files can be selected based on owner (user name or uid) via one or more
 *	-U options.
 * 2.12	Files can be selected based on group (group name or gid) via one o
 *	more -G options.
 * 2.13	Symlinks which appear on the command line can be followed (without
 *	following other symlinks; -H flag)
 *
 * 3	COPY ENHANCEMENTS
 * 3.1	Sparse files (lseek holes) can be copied without expanding the holes
 *	into zero filled blocks. The file copy is created with holes which are
 *	appropriate for the target filesystem
 * 3.2	Access time as well as modification time on copied file trees can be
 *	preserved with the appropriate -p options.
 * 3.3	Access time reset with the -t applies to all file nodes (including
 *	directories).
 * 3.4	Symbolic links can be followed with -L (optional in the spec).
 * 3.5	Modification or inode change time ranges can be specified via
 *	multiple -T options. These allow a user to select files whose
 *	modification or inode change time lies within a specific time range.
 * 3.6	Files can be selected based on owner (user name or uid) via one or more
 *	-U options.
 * 3.7	Files can be selected based on group (group name or gid) via one o
 *	more -G options.
 * 3.8	Symlinks which appear on the command line can be followed (without
 *	following other symlinks; -H flag)
 * 3.9  File inode change time can be checked against existing file before
 *	name modification (-D)
 * 3.10 File inode change time can be checked against existing file after
 *	name modification (-Y)
 * 3.11	File modification time can be checked against existing file after
 *	name modification (-Z)
 *
 * 4	GENERAL ENHANCEMENTS
 * 4.1	Internal structure is designed to isolate format dependent and
 *	independent functions. Formats are selected via a format driver table.
 *	This encourages the addition of new archive formats by only having to
 *	write those routines which id, read and write the archive header.
 */

/*
 * main()
 *	parse options, set up and operate as specified by the user.
 *	any operational flaw will set exit_val to non-zero
 * Return: 0 if ok, 1 otherwise
 */

int
main(int argc, char **argv)
{
	const char *tmpdir;
	size_t tdlen;

	/*
	 * Keep a reference to cwd, so we can always come back home.
	 */
	cwdfd = open(".", O_RDONLY);
	if (cwdfd < 0) {
		syswarn(1, errno, "Can't open current working directory.");
		return(exit_val);
	}

	/*
	 * Where should we put temporary files?
	 */
	if ((tmpdir = getenv("TMPDIR")) == NULL || *tmpdir == '\0')
		tmpdir = _PATH_TMP;
	tdlen = strlen(tmpdir);
	while (tdlen > 0 && tmpdir[tdlen - 1] == '/')
		tdlen--;
	tempfile = malloc(tdlen + 1 + sizeof(_TFILE_BASE));
	if (tempfile == NULL) {
		paxwarn(1, "Cannot allocate memory for temp file name.");
		return(exit_val);
	}
	if (tdlen)
		memcpy(tempfile, tmpdir, tdlen);
	tempbase = tempfile + tdlen;
	*tempbase++ = '/';

	listf = stderr;

	/*
	 * parse options, determine operational mode, general init
	 */
	options(argc, argv);
	if ((gen_init() < 0) || (tty_init() < 0))
		return(exit_val);

	/*
	 * select a primary operation mode
	 */
	switch (act) {
	case EXTRACT:
		extract();
		break;
	case ARCHIVE:
		archive();
		break;
	case APPND:
		if (gzip_program != NULL)
			errx(1, "can not gzip while appending");
		append();
		break;
	case COPY:
		copy();
		break;
	default:
		act = LIST;	/* for ar_io.c &c. */
	case LIST:
		list();
		break;
	}
	return(exit_val);
}

/*
 * sig_cleanup()
 *	when interrupted we try to do whatever delayed processing we can.
 *	This is not critical, but we really ought to limit our damage when we
 *	are aborted by the user.
 * Return:
 *	never....
 */

static void
sig_cleanup(int which_sig)
{
	/* XXX signal races */

	/*
	 * restore modes and times for any dirs we may have created
	 * or any dirs we may have read. Set vflag and vfpart so the user
	 * will clearly see the message on a line by itself.
	 */
	vflag = vfpart = 1;
	if (which_sig == SIGXCPU)
		paxwarn(0, "Cpu time limit reached, cleaning up.");
	else
		paxwarn(0, "Signal caught, cleaning up.");

	ar_close();
	proc_dir();
	if (tflag)
		atdir_end();
	exit(1);
}

/*
 * gen_init()
 *	general setup routines. Not all are required, but they really help
 *	when dealing with a medium to large sized archives.
 */

static int
gen_init(void)
{
	struct rlimit reslimit;
	struct sigaction n_hand;
	struct sigaction o_hand;

	/*
	 * Really needed to handle large archives. We can run out of memory for
	 * internal tables really fast when we have a whole lot of files...
	 */
	if (getrlimit(RLIMIT_DATA , &reslimit) == 0){
		reslimit.rlim_cur = reslimit.rlim_max;
		(void)setrlimit(RLIMIT_DATA , &reslimit);
	}

	/*
	 * should file size limits be waived? if the os limits us, this is
	 * needed if we want to write a large archive
	 */
	if (getrlimit(RLIMIT_FSIZE , &reslimit) == 0){
		reslimit.rlim_cur = reslimit.rlim_max;
		(void)setrlimit(RLIMIT_FSIZE , &reslimit);
	}

	/*
	 * increase the size the stack can grow to
	 */
	if (getrlimit(RLIMIT_STACK , &reslimit) == 0){
		reslimit.rlim_cur = reslimit.rlim_max;
		(void)setrlimit(RLIMIT_STACK , &reslimit);
	}

	/*
	 * not really needed, but doesn't hurt
	 */
#ifdef RLIMIT_RSS
	if (getrlimit(RLIMIT_RSS , &reslimit) == 0){
		reslimit.rlim_cur = reslimit.rlim_max;
		(void)setrlimit(RLIMIT_RSS , &reslimit);
	}
#endif

	/*
	 * Handle posix locale
	 *
	 * set user defines time printing format for -v option
	 */
	ltmfrmt = getenv("LC_TIME");

	/*
	 * signal handling to reset stored directory times and modes. Since
	 * we deal with broken pipes via failed writes we ignore it. We also
	 * deal with any file size limit through failed writes. Cpu time
	 * limits are caught and a cleanup is forced.
	 */
	if ((sigemptyset(&s_mask) < 0) || (sigaddset(&s_mask, SIGTERM) < 0) ||
	    (sigaddset(&s_mask,SIGINT) < 0)||(sigaddset(&s_mask,SIGHUP) < 0) ||
	    (sigaddset(&s_mask,SIGPIPE) < 0)||(sigaddset(&s_mask,SIGQUIT)<0) ||
	    (sigaddset(&s_mask,SIGXCPU) < 0)||(sigaddset(&s_mask,SIGXFSZ)<0)) {
		paxwarn(1, "Unable to set up signal mask");
		return(-1);
	}
	memset(&n_hand, 0, sizeof n_hand);
	n_hand.sa_mask = s_mask;
	n_hand.sa_flags = 0;
	n_hand.sa_handler = sig_cleanup;

	if ((sigaction(SIGHUP, &n_hand, &o_hand) < 0) &&
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGHUP, &o_hand, &o_hand) < 0))
		goto out;

	if ((sigaction(SIGTERM, &n_hand, &o_hand) < 0) &&
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGTERM, &o_hand, &o_hand) < 0))
		goto out;

	if ((sigaction(SIGINT, &n_hand, &o_hand) < 0) &&
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGINT, &o_hand, &o_hand) < 0))
		goto out;

	if ((sigaction(SIGQUIT, &n_hand, &o_hand) < 0) &&
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGQUIT, &o_hand, &o_hand) < 0))
		goto out;

	if ((sigaction(SIGXCPU, &n_hand, &o_hand) < 0) &&
	    (o_hand.sa_handler == SIG_IGN) &&
	    (sigaction(SIGXCPU, &o_hand, &o_hand) < 0))
		goto out;

	n_hand.sa_handler = SIG_IGN;
	if ((sigaction(SIGPIPE, &n_hand, &o_hand) < 0) ||
	    (sigaction(SIGXFSZ, &n_hand, &o_hand) < 0))
		goto out;
	return(0);

    out:
	syswarn(1, errno, "Unable to set up signal handler");
	return(-1);
}
@


1.1.221.1
log
@Import mircpio_20080906.orig.tar.gz
(even though this package needs a general rework, and -M dirslash too)
@
text
@@


1.1.221.2
log
@Import distfile into vendor branch
-r--r--r--  1 tg  miros-cvssrc  136185 Aug 17 09:14 /MirOS/dist/mir/cpio/paxmirabilis-20110817.cpio.gz
-rw-r--r--  1 tg  tg            138201 Aug 17 09:14 paxmirabilis_20110817.orig.tar.gz
@
text
@d1 1
a1 1
/**	$MirOS: src/bin/pax/pax.c,v 1.8 2011/08/16 13:50:18 tg Exp $ */
d57 1
a57 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.8 2011/08/16 13:50:18 tg Exp $");
d60 1
a60 1
static void sig_cleanup(int) __attribute__((__noreturn__));
@


1.1.221.3
log
@-rw-r--r--   1 tg  tg  138869 Feb 12 02:14 pax_20120211.orig.tar.gz
-rw-r--r--   1 tg  tg  136890 Feb 12 02:14 paxmirabilis-20120211.cpio.gz
@
text
@d1 2
a2 1
/*	$OpenBSD: pax.c,v 1.32 2011/05/26 14:42:06 deraadt Exp $	*/
a5 2
 * Copyright (c) 2012
 *	Thorsten Glaser <tg@@mirbsd.org>
d54 4
a57 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.12 2012/02/12 01:22:20 tg Exp $");
a230 3
	/* may not be a constant, thus initialising early */
	listf = stderr;

d258 2
d306 1
a306 1
	char errbuf[80];
a313 2

	/* paxwarn() uses stdio; fake it as well as we can */
d315 1
a315 2
		strlcpy(errbuf, "CPU time limit reached, cleaning up.",
		    sizeof errbuf);
d317 1
a317 6
		strlcpy(errbuf, "Signal caught, cleaning up.",
		    sizeof errbuf);
	if (!write(STDERR_FILENO, errbuf, strlen(errbuf))) {
		/* dummy, to keep fortified gcc quiet */
		errbuf[0] = '\0';
	}
d319 2
a320 2
	ar_close();			/* XXX signal race */
	proc_dir();			/* XXX signal race */
d322 2
a323 2
		atdir_end();		/* XXX signal race */
	_exit(1);
d385 1
a385 1
	 * deal with any file size limit through failed writes. CPU time
d400 1
a400 1
	if ((sigaction(SIGHUP, &n_hand, &o_hand) < 0) || (
d402 1
a402 1
	    (sigaction(SIGHUP, &o_hand, &o_hand) < 0)))
d405 1
a405 1
	if ((sigaction(SIGTERM, &n_hand, &o_hand) < 0) || (
d407 1
a407 1
	    (sigaction(SIGTERM, &o_hand, &o_hand) < 0)))
d410 1
a410 1
	if ((sigaction(SIGINT, &n_hand, &o_hand) < 0) || (
d412 1
a412 1
	    (sigaction(SIGINT, &o_hand, &o_hand) < 0)))
d415 1
a415 1
	if ((sigaction(SIGQUIT, &n_hand, &o_hand) < 0) || (
d417 1
a417 1
	    (sigaction(SIGQUIT, &o_hand, &o_hand) < 0)))
d420 1
a420 1
	if ((sigaction(SIGXCPU, &n_hand, &o_hand) < 0) || (
d422 1
a422 1
	    (sigaction(SIGXCPU, &o_hand, &o_hand) < 0)))
@


1.1.221.4
log
@-rw-r--r--   1 tg    tg     - 138212 Feb 16 17:54 pax_20120216.orig.tar.gz
@
text
@d55 1
a55 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.16 2012/02/16 17:34:35 tg Exp $");
a77 1
int	Vflag = 0;		/* print a dot for each file processed */
d86 1
a86 1
int	vfpart = 0;		/* is partial verbose output in progress */
d277 2
a278 2
		if (compress_program != NULL)
			errx(1, "cannot compress while appending");
d285 1
a285 2
		/* for ar_io.c etc. */
		act = LIST;
d305 1
a305 8
	/*
	 * The definition of this array doubles as compile-time assert
	 * on the size of long, off_t, and whether LONG_OFF_T is used,
	 * or not, correctly; target size is 80, error size -1.
	 */
	char errbuf[((sizeof(long) >= 4) &&
	    (sizeof(ot_type) >= 4) &&
	    (sizeof(ot_type) == sizeof(off_t))) ? 80 : -1];
@


1.1.221.5
log
@pax_20120520.orig.tar.gz
@
text
@a51 1
#include <time.h>
d55 1
a55 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.17 2012/05/20 16:13:19 tg Exp $");
@


1.1.221.6
log
@import prospective paxmirabilis of today into mircpio debian packaging
@
text
@d1 1
a1 1
/*	$OpenBSD: pax.c,v 1.33 2012/04/19 04:26:46 deraadt Exp $	*/
d56 1
a56 1
__RCSID("$MirOS: src/bin/pax/pax.c,v 1.19 2012/06/05 18:22:57 tg Exp $");
d326 1
a326 1
		strlcpy(errbuf, "CPU time limit reached, cleaning up.\n",
d329 1
a329 1
		strlcpy(errbuf, "Signal caught, cleaning up.\n",
d448 1
a448 1
 out:
@


